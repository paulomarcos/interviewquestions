q1:
  question: Tell me about yourself.
  example: I'm an experienced software engineer who constantly seeks out innovative solutions to everyday problems. In my seven years in this industry, I've honed my analytical thinking and collaboration skills, and I love working with a team. I've also had the opportunity to serve as the software engineer lead for three projects with First Technology.
  explanation: Focus on the job in question. Think about what makes you unique. Start with an overview. Mention prior creer highlights. Provide examples to illustrate. Conclude with your future goals. 
q2:
  question: What is something you are proud of?
  example: Last year I received a commendation from my boss because I had solved a bug that was inside the system for over three months, and with that I saved the company 10% of monthly server costs.
  explanation: Pick one or two of your biggest achievements in your work, provide some context, the tasks and results and fill in with some data to back you up.
q3: 
  question: What is your biggest weakness?
  example: I carefully read your job posting and unfortunately I feel that my biggest weakness is my lack of experience using XX secondary language. I believe with all my other skills I will be still valuable to your company and I am sure I will be able to pick up on that language in no time due to my experience with CC and DD languages.
  explanation: Avoid using personal, non-work related weaknesses since they are not relevant to the job. Rather, focus on one of the secondary requirements on the job posting and provide some context that will support you learning and developing that as a new skill. This will show that you are honest and willing to work hard to overcome any issues.
q4: 
  question: What is your biggest achievement?
  example: Add example here.
  explanation: Add explanation here.
q5: 
  question: Tell me about a time when you failed.
  example: Add example here.
  explanation: Add explanation here.
q6: 
  question: Tell me about a time when you overcame an issue.
  example: Add example here.
  explanation: Add explanation here.
q7: 
  question: Tell me when you successfully completed a project.
  example: Add example here.
  explanation: Add explanation here.
q8: 
  question: What are you looking for in this job?
  example: Add example here.
  explanation: Add explanation here.
q9: 
  question: Why should we hire you?
  example: Add example here.
  explanation: Add explanation here.
q10: 
  question: Talk about some mistakes you learned from.
  example: Add example here.
  explanation: Add explanation here.
q11: 
  question: Do you enjoy working with a team or alone?
  example: Add example here.
  explanation: Add explanation here.
q12: 
  question: How do you keep your skills sharp and up to date?
  example: Add example here.
  explanation: Add explanation here.
q13:
  question: What programming languages are you familiar with?
  example: I am proficient in Java, C++, JavaScript, C#, Ruby and Python. Of these programming languages, I feel most comfortable working with Java, C# and C++. In my previous role, I worked mainly with Java to create applications that worked across multiple platforms. I also used C++ to develop a new operating system that worked with the applications I engineered. Using C#, I was able to improve my productivity when developing web-based apps and software.
  explanation: A software engineer should have experience with a wide range of programming languages. This knowledge is vital to having success in this role. Before your interview, review the job description to see if they mention whether or not you'll need programming language experience for the role. Respond with languages you're familiar with that match the employer's needs.
q14:
  question: Describe the last project you worked on, including any obstacles and your contributions to its success.
  example: A previous employer tasked me with creating an internal online learning and training program for employees. The purpose of the program was to make sure all employees received proper training on certain topics, including customer service, compliance with legal requirements and workplace ethics. I began by researching other similar training systems to figure out what worked and what didn't. Next, I used Java to code a simple program, which I then used to upload training courses. After testing the simplified program, I added elements to make it more engaging to employees, such as games and interactive quizzes. This program was well-received by the employees of the organization, and their customer service success rates increased by 25% after all team members took the required course.
  explanation: A question relating to a specific project will help the interviewer better understand your process and how you handle adversity while working on a specific task. As you answer this question, use the STAR method (Situation, Task, Action and Result) to craft a detailed, informative answer.
q15:
  question: What are your thoughts on declarative vs. imperative paradigms such as functional and object-oriented programming?
  example: There was a project where we were tasked with reworking the browser client application. It used an imperative, object-oriented approach with many of the custom controls getting much of their functionality from a growing inheritance hierarchy. We took this as an opportunity to shift to a more declarative approach. After the conversion, we saw a dramatic decline in state-related bugs as we were no longer manually updating the interface in response to events. This had previously been the most common type of user-reported bug. We did, however, have to make adjustments in a few key places. In more dynamic, performance-sensitive portions of the application, the caching mechanisms we implemented to prevent excessive recalculation were becoming overly complex. We simplified this by switching back to an imperative approach to updating the component.
  explanation: “Programming paradigm” is a broad categorization for languages as either declarative or imperative. However, it is useful to consider these general programming styles rather than concrete language directives. While certain approaches may be cumbersome in some, there are many that are not as rigid. Languages such as JavaScript and Java allow either approach to be taken, even if they lend themselves toward one approach over another. With questions like this, employers want to gauge your familiarity with more abstract concepts in software engineering. There are many approaches for writing high-quality, maintainable software. Intelligently implementing a programming paradigm requires knowing at least some of the benefits and trade-offs of each.
q16:
  question: What are your most used design patterns and in what contexts do you use them?
  example: For gaming projects, my level state and player character are generally implemented as singletons. For enemy creation, I’ll use a factory that will produce differing enemies based on some inputs. Additionally, the bullets being fired by the character will be implemented in an object pool to avoid performance hits from excessive instantiation and garbage collection. If the game is more complex, I may switch to a compositional model such as Entity-Component-System. The system functions would then leverage dependency injection to better separate concerns and increase testability of the game logic.
  explanation: This probes your knowledge of more abstract, theoretical concepts. Very few people are familiar with all of the formalized software design patterns. In fact, many well-established engineers have a hard time even naming more than a few. After reviewing the topic, you may realize that you leverage many of these patterns daily, even if you aren't aware of the formal name. Reviewing these concepts helps provide a common shorthand, streamlining complex discussions.
q17:
  question: What is “Agile” software development and what are your thoughts on it?
  example: Agile software development is a process that focuses on incremental delivery by the team as a whole. The project is broken up into small chunks that are able to be completed within a given timeframe called ‘sprints.’ In my previous role, we were quite successful in adopting the process. We used two-week sprints and kept high contact with many face-to-face discussions to review questions and concerns as they arose. In addition, we had daily standup meetings to keep everyone synced on team progress. The only adjustment to the process I would have made was in regard to our standup meetings. The name ‘standup’ refers to literal standing meetings to encourage focus and brevity. However, our meetings tended to transition over into standard status meetings for our team lead rather than remaining a time for our team to sync. Other than this, the process really did facilitate delivering higher quality software on a more predictable timetable.
  explanation: No matter your opinion, wide industry adoption means you will likely work within the framework at some point in your career. You should be capable of articulating the details of the process. Try using concrete examples from your experience. In your answer, address areas of the process such as... What worked about the process? What did not? Did your team deviate from the recommendations? Did that work to your benefit or detriment
q18:
  question: What are your thoughts on software testing?
  example: Testing is vital to producing high-quality software for our users. However, in a new project, I generally will not lead with them. I think of tests as a tool for locking down mature functionality. Often, the project concept varies quite a bit from the final product as we begin collecting usage metrics and feedback. For this reason, I will begin with simple manual testing. As the feature set stabilizes, I will then begin to implement tests. The majority of my test suite will be unit tests that target key areas of the application. Additionally, I’ll have a narrow set of integration tests leveraging Selenium. To ensure execution time isn’t excessive, I’ll focus those tests on the most vital user interactions. Finally, assuming the infrastructure provided by the DevOps team supports it, a canary deployment will be leveraged for each release to ensure any potential impact of missed bugs is limited.
  explanation: Approaches to testing range from manually testing the application to writing test suites for individual code modules, or “unit testing.” Within these approaches, there are many schools of thought. For example, unit tests may be written in a strict test-driven process where failing tests are written before any business logic, aiming for 100% of the code to be exercised. You should have informed opinions on why you favor one approach over another. It will demonstrate that you are aware of the range of methodologies and have made a choice based on sound reasoning. Similar to speaking about Agile software development, negative statements should be avoided in general.
q19:
  question: Describe a difficult bug you were tasked with fixing in a large application. How did you debug the issue?
  example: I received a bug report from our DevOps team about one of our databases being stressed from an expensive query being called excessively from the UI. I first checked the logs to find out when the trouble started. This gave me the rough commit range in which the bug was introduced. I was able to reproduce the bug on the latest piece of code, but only in production. I ran a git bisect to isolate the specific commit that introduced the bug and pulled the branch. However, I was not able to reproduce the issue. I went to the UI to debug using the browser devtools. Sourcemaps are not available in our production environment, so I had to map the minified JavaScript code to the source CoffeeScript code. I was able to determine that the offending method was being called on every page as opposed to the occasional call from a lesser-used specific feature. Diving back into the commit I’d identified earlier, I found no change in reference to the method. The only approximate change I could find was an unrelated tweak to a line in a file that had a reference to it that had been “commented out” about three years prior. I decided to deploy some distinct logging statements to ensure that I had correctly identified the method. My logging confirmed the connection. After some additional rounds of logging, I was able to identify an unfortunate bug in CoffeeScript in which the code that had been “commented out” years earlier was being included in minified production code due to an alignment of the tweak and another piece of code from another developer that had been merged into master minutes before.
  explanation: Bugs usually appear in new applications and software programs, and it's a software engineer's responsibility to locate and resolve these issues. Difficult bugs are often the result of an unusual alignment of conditions. Hearing your experience of resolving bugs explores several aspects of your skills including critical thinking and how well you handle stress and pressure.

